    1. Ссылки.
Переменные (и константы) в JavaScript могут хранить два вида данных: примитивные и ссылочные. К примитивным относятся все примитивные типы: числа, строки, булеан и так далее. К ссылочным – объекты. Объекты, в общем смысле, изучаются только в следующем курсе, но массив внутри – это тоже объект:

typeof []; // 'object'
Другой способ убедиться в том, что массивы являются ссылками – создать несколько констант, содержащих один массив, и посмотреть, как они меняются:

const items = [1, 2];
// Ссылаются на один и тот же массив
const items2 = items;
items2.push(3);

console.log(items2); // => [1, 2, 3]
console.log(items); // => [1, 2, 3]
items2 === items; // true

Более того, если передать массив в какую-то функцию, которая его изменяет, то массив тоже изменится. Ведь в функцию передается именно ссылка на массив. Посмотрите на пример:

const f = (coll) => coll.push('wow');

const items = ['one'];
f(items);
console.log(items); // => [ 'one', 'wow' ]
f(items);
console.log(items); // => [ 'one', 'wow', 'wow' ]
    2. Проектирование функций.
    Изменение массива может повлечь за собой неожиданные эффекты. Представьте себе функцию last(), которая извлекает последний элемент из массива. Она могла бы быть написана так:

// Метод .pop извлекает последний элемент из массива
// Он изменяет массив, удаляя оттуда этот элемент
const last = (coll) => coll.pop();
    Правильная реализация данной функции выглядит так:

// Метод .at() возвращает элемент массива по указанному индексу
// Он не меняет сам массив
// Индекс -1 означает первый элемент с конца
const last = (coll) => coll.at(-1);
    Есть ровно одна причина, по которой так делают – производительность. Именно поэтому некоторые встроенные методы массивов меняют их, например reverse() или sort():

const items = [3, 8, 1];

// Нет присвоения результата, массив изменяется напрямую
items.sort();
console.log(items); // => [1, 3, 8]

items.reverse();
console.log(items); // => [8, 3, 1]

    Метод concat(), в отличие от sort(), возвращает новый массив.